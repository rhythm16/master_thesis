@book{IEEE-1363,
  author =       {{IEEE Std 1363-2000}},
  title =        {{IEEE} Standard Specifications for Public-Key Cryptography},
  address =      {New York},
  publisher =    {IEEE},
  year =         2000
}

@inproceedings{kocher99,
  author =       {C. Kocher and J. Jaffe and B. Jun},
  title =        {Differential Power Analysis},
  editor =       {M. Wiener},
  booktitle =    {Advances in Cryptology ({CRYPTO}~'99)},
  series =       {Lecture Notes in Computer Science},
  volume =       1666,
  pages =        {388-397},
  publisher =    {Springer-Verlag},
  month =        {August},
  year =         1999
}

@incollection{Krasnogor2004e,
  author =       {N. Krasnogor},
  title =        {Towards robust memetic algorithms},
  booktitle =    {Recent Advances in Memetic Algorithms},
  publisher =    {Springer Berlin Heidelberg},
  year =         2004,
  pages =        {185-207},
  editor =       {W.E. Hart and N. Krasnogor and J.E. Smith},
  volume =       166,
  series =       {Studies in Fuzziness and Soft Computing},
  address =      {New York},
}

@incollection{zjsw,
  author =       {班固},
  title =        {苏武传},
  booktitle =    {传记散文英华},
  publisher =    {湖北人民出版社},
  year =         1998,
  pages =        {65-69},
  editor =       {郑在瀛 and 汪超宏 and 周文复},
  volume =       2,
  series =       {新古文观止丛书},
  address =      {武汉},
  language =     "chinese",
}

@inbook{clzs,
  author =       {阎真},
  title =        {沧浪之水},
  chapter =      {大人物还是讲人情的},
  pages =        {185-207},
  publisher =    {人民文学出版社},
  year =         2001,
  language =     "chinese",
}

@book{tex,
  author =       "Donald E. Knuth",
  title =        "The {\TeX} Book",
  publisher =    "Addison-Wesley Publishing Company",
  address =      "Reading, MA",
  year =         1989,
  edition =      "15th",
}

@book{companion,
  author =       "Michel Goosens and Frank Mittelbach and Alexander Samarin",
  title =        "The {\LaTeX} Companion",
  publisher =    "Addison-Wesley Publishing Company",
  address =      "Reading, MA",
  PAGES =        "112--125",
  year =         1994,
}

@article{ELIDRISSI94,
  author =       "{Chafik El Idrissi}, M. and {Roney}, A. and {Frigon}, C. and
                  {Larzilli{\`e}re}, M.",
  title =        "Measurements of total kinetic-energy released to the {$N=2$}
                  dissociation limit of {H}$_2$ --- evidence of the dissociation
                  of very high vibrational {R}ydberg states of {H}$_2$ by
                  doubly-excited states",
  journal =      "Chemical Physics Letters",
  pages =        "260-266",
  volume =       224,
  number =       10,
  year =         1994,
}

@article{MELLINGER96,
  author =       "Mellinger, A. and Vidal, C. R. and Jungen, Ch.",
  title =        "Laser reduced fluorescence study of the carbon-monoxide nd
                  triplet {R}ydberg series-experimental results and multichannel
                  quantum-defect analysis",
  journal =      "J. Chem. Phys.",
  pages =        "8913-8921",
  volume =       104,
  number =       5,
  year =         1996,
}

@article{SHELL02,
  author =       "Michael Shell",
  title =        "How to Use the {IEEEtran \LaTeX} Class",
  journal =      "Journal of {\LaTeX} Class Files",
  year =         2002,
  volume =       12,
  number =       4,
  pages =        "100--120"
}

@TechReport{NPB2,
  title =        {The {NAS} Parallel Benchmarks 2.0},
  author =       {Alex Woo and David Bailey and Maurice Yarrow and Wijngaart
                  Wijngaart and Tim Harris and William Saphir},
  year =         1995,
  month =        dec # "~05",
  institution =  "The Pennsylvania State University CiteSeer Archives",
  url =          "http://www.nasa.org/"
}

@inproceedings{DPMG,
  author =       {Kim, Sangbum and Woo, Namyoon and Yeom, Heon Y. and Park,
                  Taesoon and Park, Hyoungwoo},
  title =        {Design and {I}mplementation of {D}ynamic {P}rocess
                  {M}anagement for {G}rid-enabled {MPICH}},
  booktitle =    {the 10th European PVM/MPI Users' Group Conference},
  year =         2003,
  address =      {Venice, Italy},
  month =        sep,
}

@inproceedings{cnproceed,
  author =       {王重阳 and 黄药师 and 欧阳峰 and 洪七公 and 段皇帝},
  title =        {武林高手从入门到精通},
  booktitle =    {第~$N$~次华山论剑},
  year =         2006,
  address =      {西安, 中国},
  month =        sep,
  language =     "chinese",
}

@article{cnarticle,
  author =       "贾宝玉 and 林黛玉 and 薛宝钗 and 贾探春",
  title =        "论刘姥姥食量大如牛之现实意义",
  journal =      "红楼梦杂谈",
  pages =        "260--266",
  volume =       224,
  year =         1800,
  language =     "chinese",
}

@mastersthesis{zhubajie,
  author =       {猪八戒},
  title =        {论流体食物的持久保存},
  school =       {广寒宫大学},
  year =         2005,
  address =      {北京},
  language =     "chinese",
}

@phdthesis{shaheshang,
  author =       {沙和尚},
  title =        {论流沙河的综合治理},
  school =       {清华大学},
  year =         2005,
  address =      {北京},
  language =     "chinese",
}

@mastersthesis{metamori2004,
  author =       {Ashwin Raju Jeyakumar},
  title =        {Metamori: A library for Incremental File Checkpointing},
  school =       {Virgina Tech},
  year =         2004,
  month =        jun # "~21",
  address =      {Blacksburg},
}

@phdthesis{FistSystem01,
  author =       "Erez Zadok",
  title =        "{FiST: A System for Stackable File System Code Generation}",
  year =         2001,
  month =        "May",
  school =       "Computer Science Department, Columbia University",
  address =      "USA"
}

@inbook{ColdSources,
  author =       {P. Gr{\"o}ning and L. Nilsson and P. Ruffieux and R.
                  Clergereaux and O. Gr{\"o}ning},
  title =        {Encyclopedia of Nanoscience and Nanotechnology},
  pages =        {547--579},
  publisher =    {American Scientific Publishers},
  year =         2004,
  volume =       1,
}

@online{chuban2001,
  author =      {萧钰},
  title =       {出版业信息化迈入快车道},
  modifydate =  {2001-12-19},
  citedate =    {2002-04-15},
  url =         {http://www.creader.com/news/200112190019.htm},
  language =    "chinese",
}

@online{oclc2000,
  author =      {{Online Computer Library Center, Inc.}},
  title =       {History of {OCLC}},
  citedate =    {2000-01-08},
  url =         {http://www.oclc.org/about/history/default.htm},
}


@online{thuthesis,
  author =      {薛瑞尼},
  title =       {\thuthesis: 清华大学学位论文模板},
  citedate =    {2017-12-02},
  url =         {https://github.com/xueruini/thuthesis},
  language =    "chinese",
  year =        2017,
}

@misc{hackbench,
  author = {Rusty Russell},
  title = {{Hackbench}},
  howpublished = {\url{http://people.redhat.com/mingo/cfs-scheduler/tools/hackbench.c}},
  year = 2008,
  month = jan,
}

@misc{netperf,
  title = {Netperf},
  author = {Rick Jones},
  howpublished = {\url{https://github.com/HewlettPackard/netperf}},
  year = 2018,
  month = jun
}

@misc{ab,
  author = {{The Apache Software Foundation}},
  title = {{ab - Apache HTTP server benchmarking tool}},
  howpublished = {\url{http://httpd.apache.org/docs/2.4/programs/ab.html}},
  year = 2015,
  month = apr,
}

@misc{memtier,
  author = {{Redis Labs}},
  title = {{memtier\_benchmark}},
  howpublished = {\url{https://github.com/RedisLabs/memtier_benchmark}},
  year = 2015,
  month = apr,
}

@misc{YCSB,
  author = {{Brian Cooper}},
  title = {{Yahoo! Cloud Serving Benchmark}},
  howpublished = {\url{https://github.com/brianfrankcooper/YCSB}},
  year = 2021,
  month = feb,
}

@misc{sekvm-artifact,
    author = {{Columbia University}},
    title = {{SOSP 21: Artifact Evaluation: Verifying a Multiprocessor Hypervisor on Arm Relaxed Memory Hardware}},
    howpublished = {\url{https://github.com/VeriGu/sosp-paper211-ae}},
    year = 2021,
    month = sep
}

@inproceedings{hypsec,
author = {Li, Shih-Wei and Koh, John S. and Nieh, Jason},
title = {Protecting Cloud Virtual Machines from Commodity Hypervisor and Host Operating System Exploits},
year = {2019},
isbn = {9781939133069},
publisher = {USENIX Association},
address = {USA},
abstract = {Hypervisors are widely deployed by cloud computing providers to support virtual machines, but their growing complexity poses a security risk as large codebases contain many vulnerabilities. We have created HypSec, a new hypervisor design for retrofitting an existing commodity hypervisor using microkernel principles to reduce its trusted computing base while protecting the confidentiality and integrity of virtual machines. HypSec partitions the hypervisor into an untrusted host that performs most complex hypervisor functionality without access to virtual machine data, and a trusted core that provides access control to virtual machine data and performs basic CPU and memory virtualization. Hardware virtualization support is used to isolate and protect the trusted core and execute it at a higher privilege level so it can mediate virtual machine exceptions and protect VM data in CPU and memory. HypSec takes an end-to-end approach to securing I/O to simplify its design, with applications increasingly using secure network connections in the cloud. We have used HypSec to retrofit KVM, showing how our approach can support a widely-used full-featured hypervisor integrated with a commodity operating system. The implementation has a trusted computing base of only a few thousand lines of code, many orders of magnitude less than KVM. We show that HypSec protects the confidentiality and integrity of virtual machines running unmodified guest operating systems while only incurring modest performance overhead for real application workloads.},
booktitle = {Proceedings of the 28th USENIX Conference on Security Symposium},
pages = {1357–1374},
numpages = {18},
location = {Santa Clara, CA, USA},
series = {SEC'19}
}

@inproceedings{ruststudy,
author = {Qin, Boqin and Chen, Yilun and Yu, Zeming and Song, Linhai and Zhang, Yiying},
title = {Understanding Memory and Thread Safety Practices and Issues in Real-World Rust Programs},
year = {2020},
isbn = {9781450376136},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3385412.3386036},
doi = {10.1145/3385412.3386036},
abstract = {Rust is a young programming language designed for systems software development. It aims to provide safety guarantees like high-level languages and performance efficiency like low-level languages. The core design of Rust is a set of strict safety rules enforced by compile-time checking. To support more low-level controls, Rust allows programmers to bypass these compiler checks to write unsafe code. It is important to understand what safety issues exist in real Rust programs and how Rust safety mechanisms impact programming practices. We performed the first empirical study of Rust by close, manual inspection of 850 unsafe code usages and 170 bugs in five open-source Rust projects, five widely-used Rust libraries, two online security databases, and the Rust standard library. Our study answers three important questions: how and why do programmers write unsafe code, what memory-safety issues real Rust programs have, and what concurrency bugs Rust programmers make. Our study reveals interesting real-world Rust program behaviors and new issues Rust programmers make. Based on our study results, we propose several directions of building Rust bug detectors and built two static bug detectors, both of which revealed previously unknown bugs.},
booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {763–779},
numpages = {17},
keywords = {Bug Study, Memory Bug, Rust, Concurrency Bug},
location = {London, UK},
series = {PLDI 2020}
}

@inproceedings{lisosp21,
author = {Li, Dingji and Mi, Zeyu and Xia, Yubin and Zang, Binyu and Chen, Haibo and Guan, Haibing},
title = {TwinVisor: Hardware-Isolated Confidential Virtual Machines for ARM},
year = {2021},
isbn = {9781450387095},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3477132.3483554},
doi = {10.1145/3477132.3483554},
booktitle = {Proceedings of the ACM SIGOPS 28th Symposium on Operating Systems Principles},
pages = {638–654},
numpages = {17},
keywords = {Confidential Computing, ARM TrustZone, Virtualization, Cloud Computing},
location = {Virtual Event, Germany},
series = {SOSP '21}
}

@inproceedings{zhang2011cloudvisor,
  author = {Fengzhe Zhang and Jin Chen and Haibo Chen and Binyu Zang},
  title = {{CloudVisor: Retrofitting Protection of Virtual Machines in Multi-tenant Cloud with Nested Virtualization}},
  booktitle = {Proceedings of the 23rd ACM Symposium on Operating Systems
  Principles (SOSP 2011)},
  year = {2011},
  month = oct,
  isbn = {978-1-4503-0977-6},
  address = {Cascais, Portugal},
  pages = {203--216},
  numpages = {14},
}

@inproceedings {zeyu20usenix,
author = {Zeyu Mi and Dingji Li and Haibo Chen and Binyu Zang and Haibing Guan},
title = {(Mostly) Exitless {VM} Protection from Untrusted Hypervisor through Disaggregated Nested Virtualization},
booktitle = {29th USENIX Security Symposium (USENIX Security 20)},
year = {2020},
isbn = {978-1-939133-17-5},
pages = {1695--1712},
url = {https://www.usenix.org/conference/usenixsecurity20/presentation/mi},
publisher = {USENIX Association},
month = aug,
}

@inproceedings{fidelius-hpca18,
  author={Wu, Yuming and Liu, Yutao and Liu, Ruifeng and Chen, Haibo and Zang, Binyu and Guan, Haibing},
  booktitle={2018 IEEE International Symposium on High Performance Computer Architecture (HPCA)},
  title={Comprehensive VM Protection Against Untrusted Hypervisor Through Retrofitted AMD Memory Encryption},
  year={2018},
  volume={},
  number={},
  pages={441-453},
  doi={10.1109/HPCA.2018.00045}
}

@inproceedings{sekvm,
author = {Li, Shih-Wei and Li, Xupeng and Gu, Ronghui and Nieh, Jason and Zhuang Hui, John},
booktitle = {2021 IEEE Symposium on Security and Privacy (SP)},
title = {A Secure and Formally Verified Linux KVM Hypervisor},
year = {2021},
volume = {},
number = {},
pages = {1782-1799},
doi = {10.1109/SP40001.2021.00049}
}

@misc{pkvm,
  title = {{KVM for Android}},
  year = {2020},
  month = nov,
  organization = {{LWN.net}},
  author = {{Jake Edge}},
  note = {\url{https://lwn.net/Articles/836693/}},
}

@inproceedings{kivity07kvm,
 author = {Avi Kivity and Yaniv Kamay and Dor Laor and Uri Lublin and Anthony Liguori},
 title = {{KVM}: the {L}inux {V}irtual {M}achine {M}onitor},
 booktitle = {In Proceedings of the 2007 Ottawa Linux Symposium (OLS 2007)},
 year = {2007},
 month = jun,
 address = {Ottawa, ON, Canada}
}

@misc{hyperv,
  author = {Microsoft},
  title = {{Hyper-V Technology Overview}},
  year = {2016},
  month = nov,
  howpublished = {\url{https://docs.microsoft.com/en-us/windows-server/virtualization/hyper-v/hyper-v-technology-overview}}
}

@InProceedings{NrOS,
  title={NrOS: Effective Replication and Sharing in an Operating System.},
  author={Bhardwaj, Ankit and Kulkarni, Chinmay and Achermann, Reto and Calciu, Irina and Kashyap, Sanidhya and Stutsman, Ryan and Tai, Amy and Zellweger, Gerd},
  booktitle={OSDI},
  pages={295--312},
  year={2021}
}

@InProceedings{Redleaf,
  title={Redleaf: Isolation and communication in a safe operating system},
  author={Narayanan, Vikram and Huang, Tianjiao and Detweiler, David and Appel, Dan and Li, Zhaofeng and Zellweger, Gerd and Burtsev, Anton},
  booktitle={Proceedings of the 14th USENIX Conference on Operating Systems Design and Implementation},
  pages={21--39},
  year={2020}
}

@InProceedings{TockOS,
  title={Multiprogramming a 64kb computer safely and efficiently},
  author={Levy, Amit and Campbell, Bradford and Ghena, Branden and Giffin, Daniel B and Pannuto, Pat and Dutta, Prabal and Levis, Philip},
  booktitle={Proceedings of the 26th Symposium on Operating Systems Principles},
  pages={234--251},
  year={2017}
}

@inproceedings {theseus,
author = {Kevin Boos and Namitha Liyanage and Ramla Ijaz and Lin Zhong},
title = {Theseus: an Experiment in Operating System Structure and State Management},
booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation (OSDI 20)},
year = {2020},
isbn = {978-1-939133-19-9},
pages = {1--19},
url = {https://www.usenix.org/conference/osdi20/presentation/boos},
publisher = {USENIX Association},
month = nov,
}

@misc{DuVisor,
      title={DuVisor: a User-level Hypervisor Through Delegated Virtualization}, 
      author={Jiahao Chen and Dingji Li and Zeyu Mi and Yuxuan Liu and Binyu Zang and Haibing Guan and Haibo Chen},
      year={2022},
      eprint={2201.09652},
      archivePrefix={arXiv},
      primaryClass={cs.OS}
}

@inproceedings{RustyHermit,
author = {Sung, Mincheol and Olivier, Pierre and Lankes, Stefan and Ravindran, Binoy},
title = {Intra-Unikernel Isolation with Intel Memory Protection Keys},
year = {2020},
isbn = {9781450375542},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3381052.3381326},
doi = {10.1145/3381052.3381326},
abstract = {Unikernels are minimal, single-purpose virtual machines. This new operating system model promises numerous benefits within many application domains in terms of lightweightness, performance, and security. Although the isolation between unikernels is generally recognized as strong, there is no isolation within a unikernel itself. This is due to the use of a single, unprotected address space, a basic principle of unikernels that provide their lightweightness and performance benefits. In this paper, we propose a new design that brings memory isolation inside a unikernel instance while keeping a single address space. We leverage Intel's Memory Protection Key to do so without impacting the lightweightness and performance benefits of unikernels. We implement our isolation scheme within an existing unikernel written in Rust and use it to provide isolation between trusted and untrusted components: we isolate (1) safe kernel code from unsafe kernel code and (2) kernel code from user code. Evaluation shows that our system provides such isolation with very low performance overhead. Notably, the unikernel with our isolation exhibits only 0.6% slowdown on a set of macro-benchmarks.},
booktitle = {Proceedings of the 16th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments},
pages = {143–156},
numpages = {14},
keywords = {unikernels, memory safety, memory protection keys},
location = {Lausanne, Switzerland},
series = {VEE '20}
}

@INPROCEEDINGS{servo,
author = {Anderson, Brian and Bergstrom, Lars and Goregaokar, Manish and Matthews, Josh and McAllister, Keegan and Moffitt, Jack and Sapin, Simon},
booktitle = {2016 IEEE/ACM 38th International Conference on Software Engineering Companion (ICSE-C)},
title = {Engineering the Servo Web Browser Engine Using Rust},
year = {2016},
volume = {},
number = {},
pages = {81-89},
doi = {}
}

@inproceedings{rustsgx,
author = {Wang, Huibo and Wang, Pei and Ding, Yu and Sun, Mingshen and Jing, Yiming and Duan, Ran and Li, Long and Zhang, Yulong and Wei, Tao and Lin, Zhiqiang},
title = {Towards Memory Safe Enclave Programming with Rust-SGX},
year = {2019},
isbn = {9781450367479},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3319535.3354241},
doi = {10.1145/3319535.3354241},
abstract = {Intel Software Guard eXtension (SGX), a hardware supported trusted execution environment (TEE), is designed to protect security critical applications. However, it does not terminate traditional memory corruption vulnerabilities for the software running inside enclave, since enclave software is still developed with type unsafe languages such as C/C++. This paper presents RUST-SGX, an efficient and layered approach to exterminating memory corruption for software running inside SGX enclaves. The key idea is to enable the development of enclave programs with an efficient memory safe system language Rust with a RUST-SGX SDK by solving the key challenges of how to (1) make the SGX software memory safe and (2) meanwhile run as efficiently as with the SDK provided by Intel. We therefore propose to build RUST-SGX atop Intel SGX SDK, and tame unsafe components with formally proven memory safety. We have implemented RUST-SGX and tested with a series of benchmark programs. Our evaluation results show that RUST-SGX imposes little extra overhead (less than 5% with respect to the SGX specific features and services compared to software developed by Intel SGX SDK), and meanwhile have stronger memory safety.},
booktitle = {Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security},
pages = {2333–2350},
numpages = {18},
keywords = {memory safety, SGX, rust programming language, type system soundness},
location = {London, United Kingdom},
series = {CCS '19}
}

@inproceedings{rustee,
author = {Wan, Shengye and Sun, Mingshen and Sun, Kun and Zhang, Ning and He, Xu},
title = {RusTEE: Developing Memory-Safe ARM TrustZone Applications},
year = {2020},
isbn = {9781450388580},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3427228.3427262},
doi = {10.1145/3427228.3427262},
abstract = {In the past decade, Trusted Execution Environment (TEE) provided by ARM TrustZone is becoming one of the primary techniques for enhancing the security of mobile devices. The isolation enforced by TrustZone can protect the trusted applications running in the TEE against malicious software in the untrusted rich execution environment (REE). However, TrustZone cannot completely prevent vulnerabilities in trusted applications residing in the TEE, which can then be used to attack other trusted applications or even the trusted OS. Previously, a number of memory corruption vulnerabilities have been reported on different TAs, which are written in memory-unsafe languages like C. Recently, various memory-safe programming languages have emerged to mitigate the prevalent memory corruption bugs. In this paper, we propose RusTEE, a trusted application mechanism that leverages Rust, a newly emerged memory-safe language, to enhance the security of TAs. Though the high-level idea is quite straight-forwarding, we resolve several challenges on adopting Rust in mobile TEEs. Specifically, since Rust currently does not support any TrustZone-assisted TEE systems, we extend the existing Rust compiler for providing such support. Also, we apply comprehensive security mechanisms to resolve two security issues of trusted applications, namely, securely invoking high-privileged system services and securely communicating with untrusted REE. We implement a prototype of RusTEE as the trusted applications’ SDK, which supports both emulator and real hardware devices. The experiment shows that RusTEE can compile applications with close-to-C performance on the evaluated platforms.},
booktitle = {Annual Computer Security Applications Conference},
pages = {442–453},
numpages = {12},
keywords = {Rust, Trusted Applications, Memory-safety, TrustZone},
location = {Austin, USA},
series = {ACSAC '20}
}

@misc{bindgen,
  title={bindgen},
  author={bindgen maintainer},
  howpublished = {\url{https://github.com/rust-lang/rust-bindgen}},
  year = 2023,
}

@misc{smmu-whitepaper,
  author = {{ARM Ltd.}},
  title = {{ARM System Memory Management Unit Architecture Specification - SMMU
  architecture version 2.0}},
  howpublished = {\url{http://infocenter.arm.com/help/topic/com.arm.doc.ihi0062d.c/IHI0062D_c_system_mmu_architecture_specification.pdf}},
  year = {2016},
  month = jun,
}

@inproceedings {coldboot,
  author = {J. Alex Halderman and Seth D. Schoen and Nadia Heninger and William Clarkson and William Paul and Joseph A. Calandrino and Ariel J. Feldman and Jacob Appelbaum and Edward W. Felten},
  title = {{L}est {W}e {R}emember: {C}old {B}oot {A}ttacks on {E}ncryption {K}eys},
  booktitle = {Proceedings of the 17th USENIX Security Symposium (USENIX
  Security 2008)},
  year = {2008},
  month = jul,
  address = {San Jose, CA},
  pages = {45--60},
  numpages = {16},
}

@misc{googlesecuritywhitepaper,
  publisher = {Google Cloud},
  author = {Google},
  title = {{Google Cloud Security and Compliance Whitepaper - How Google
  protects your data.}},
  pages = {6--7},
  year = {2017},
  month = sep,
  howpublished ={\url{https://static.googleusercontent.com/media/gsuite.google.com/en//files/google-apps-security-and-compliance-whitepaper.pdf}}
}

@inproceedings{ristenpart09sc,
 author = {Thomas Ristenpart and Eran Tromer and Hovav Shacham and Stefan
 Savage},
 title = {{H}ey, {Y}ou, {G}et off of {M}y {C}loud: {E}xploring {I}nformation {L}eakage in {T}hird-party {C}ompute {C}louds},
 booktitle = {Proceedings of the 16th ACM Conference on Computer and
 Communications Security (CCS 2009)},
 year = {2009},
 month = nov,
 isbn = {978-1-60558-894-0},
 address = {Chicago, IL},
 pages = {199--212},
 numpages = {14},
}

@inproceedings{zhang12sc,
 author = {Yinqian Zhang and Ari Juels and Michael K. Reiter and Thomas
 Ristenpart},
 title = {{C}ross-{VM} {S}ide {C}hannels and {T}heir {U}se to {E}xtract {P}rivate {K}eys},
 booktitle = {Proceedings of the 2012 ACM Conference on Computer and
 Communications Security (CCS 2012)},
 year = {2012},
 month = oct,
 isbn = {978-1-4503-1651-4},
 address = {Raleigh, NC},
 pages = {305--316},
 numpages = {12},
}

@inproceedings{irazoqui15sc,
 author = {Gorka Irazoqui and Thomas Eisenbarth and Berk Sunar},
 title = {{S\$A}: {A} {S}hared {C}ache {A}ttack {T}hat {W}orks {A}cross {C}ores and {D}efies {VM} {S}andboxing -- and {I}ts {A}pplication to {AES}},
 booktitle = {Proceedings of the 2015 IEEE Symposium on Security and Privacy
 (SP 2015)},
 year = {2015},
 month = may,
 isbn = {978-1-4673-6949-7},
 address = {San Jose, CA},
 pages = {591--604},
 numpages = {14},
}

@inproceedings{zhang14sc,
 author = {Yinqian Zhang and Ari Juels and Michael K. Reiter and Thomas
 Ristenpart},
 title = {{C}ross-{T}enant {S}ide-{C}hannel {A}ttacks in {P}aaS {C}louds},
 booktitle = {Proceedings of the 2014 ACM SIGSAC Conference on Computer and
 Communications Security (CCS 2014)},
 year = {2014},
 month = nov,
 isbn = {978-1-4503-2957-6},
 location = {Scottsdale, AZ},
 pages = {990--1003},
 numpages = {14},
}

@inproceedings{liu15sc,
 author = {Fangfei Liu and Yuval Yarom and Qian Ge and Gernot Heiser and Ruby
 B. Lee},
 title = {{L}ast-{L}evel {C}ache {S}ide-{C}hannel {A}ttacks {A}re {P}ractical},
 booktitle = {Proceedings of the 2015 IEEE Symposium on Security and Privacy
 (SP 2015)},
 year = {2015},
 month = may,
 isbn = {978-1-4673-6949-7},
 pages = {605--622},
 numpages = {18},
 address = {San Jose, CA}
}

@inproceedings{backes13sc,
  title={{P}reventing {S}ide-{C}hannel {L}eaks in {W}eb {T}raffic: {A} {F}ormal {A}pproach.},
  author={Michael Backes and Goran Doychev and Boris Kopf},
  booktitle={20th Annual Network and Distributed System Security Symposium
  (NDSS 2013)},
  year={2013},
  month = feb,
  url =
  {https://www.ndss-symposium.org/ndss2013/ndss-2013-programme/preventing-side-channel-leaks-web-traffic-formal-approach/},
  address = {San Diego, CA}
}

@misc{Rust-for-Linux,
  author = {},
  title = {Rust for Linux},
  year = {2023},
  howpublished = {\url{https://rust-for-linux.com/}}
}

@misc{rust-vmm,
  author={rust-vmm maintainers},
  title={rust-vmm},
  howpublished={\url{https://github.com/rust-vmm}},
  year={2023},
}

@inproceedings {Firecracker,
author = {Alexandru Agache and Marc Brooker and Alexandra Iordache and Anthony Liguori and Rolf Neugebauer and Phil Piwonka and Diana-Maria Popa},
title = {Firecracker: Lightweight Virtualization for Serverless Applications },
booktitle = {17th USENIX Symposium on Networked Systems Design and Implementation (NSDI 20)},
year = {2020},
isbn = {978-1-939133-13-7},
address = {Santa Clara, CA},
pages = {419--434},
url = {https://www.usenix.org/conference/nsdi20/presentation/agache},
publisher = {USENIX Association},
month = feb,
}

@misc{crosvm,
  author={Google},
  title={ChromiumOS Virtual Machine Monitor},
  howpublished={\url{https://chromium.googlesource.com/chromiumos/platform/crosvm/}},
  year          = {2023},
}

@inproceedings {hyperenclave,
author = {Yuekai Jia and Shuang Liu and Wenhao Wang and Yu Chen and Zhengde Zhai and Shoumeng Yan and Zhengyu He},
title = {{HyperEnclave}: An Open and Cross-platform Trusted Execution Environment},
booktitle = {2022 USENIX Annual Technical Conference (USENIX ATC 22)},
year = {2022},
isbn = {978-1-939133-29-48},
address = {Carlsbad, CA},
pages = {437--454},
url = {https://www.usenix.org/conference/atc22/presentation/jia-yuekai},
publisher = {USENIX Association},
month = jul,
}

@misc{CloudHypervisor,
  author={},
  title={Cloud Hypervisor - Run Cloud Virtual Machines Securely and Efficiently},
  howpublished={\url{https://www.cloudhypervisor.org/}},
  year={2023},
}

@inproceedings{VMSH,
author = {Thalheim, J\"{o}rg and Okelmann, Peter and Unnibhavi, Harshavardhan and Gouicem, Redha and Bhatotia, Pramod},
title = {VMSH: Hypervisor-Agnostic Guest Overlays for VMs},
year = {2022},
isbn = {9781450391627},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3492321.3519589},
doi = {10.1145/3492321.3519589},
abstract = {Lightweight virtual machines (VMs) are prominently adopted for improved performance and dependability in cloud environments. To reduce boot up times and resource utilisation, they are usually "pre-baked" with only the minimal kernel and userland strictly required to run an application. This introduces a fundamental trade-off between the advantages of lightweight VMs and available services within a VM, usually leaning towards the former. We propose VMSH, a hypervisor-agnostic abstraction that enables on-demand attachment of services to a running VM---allowing developers to provide minimal, lightweight images without compromising their functionality. The additional applications are made available to the guest via a file system image. To ensure that the newly added services do not affect the original applications in the VM, VMSH uses lightweight isolation mechanisms based on containers. We evaluate VMSH on multiple KVM-based hypervisors and Linux LTS kernels and show that: (i) VMSH adds no overhead for the applications running in the VM, (ii) de-bloating images from the Docker registry can save up to 60% of their size on average, and (iii) VMSH enables cloud providers to offer services to customers, such as recovery shells, without interfering with their VM's execution.},
booktitle = {Proceedings of the Seventeenth European Conference on Computer Systems},
pages = {678–696},
numpages = {19},
keywords = {VM introspection, virtual machines},
location = {Rennes, France},
series = {EuroSys '22}
}

@article{Verus,
author = {Lattuada, Andrea and Hance, Travis and Cho, Chanhee and Brun, Matthias and Subasinghe, Isitha and Zhou, Yi and Howell, Jon and Parno, Bryan and Hawblitzel, Chris},
title = {Verus: Verifying Rust Programs Using Linear Ghost Types},
year = {2023},
issue_date = {April 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {OOPSLA1},
url = {https://doi.org/10.1145/3586037},
doi = {10.1145/3586037},
abstract = {The Rust programming language provides a powerful type system that checks linearity and borrowing, allowing code to safely manipulate memory without garbage collection and making Rust ideal for developing low-level, high-assurance systems. For such systems, formal verification can be useful to prove functional correctness properties beyond type safety. This paper presents Verus, an SMT-based tool for formally verifying Rust programs. With Verus, programmers express proofs and specifications using the Rust language, allowing proofs to take advantage of Rust's linear types and borrow checking. We show how this allows proofs to manipulate linearly typed permissions that let Rust code safely manipulate memory, pointers, and concurrent resources. Verus organizes proofs and specifications using a novel mode system that distinguishes specifications, which are not checked for linearity and borrowing, from executable code and proofs, which are checked for linearity and borrowing. We formalize Verus' linearity, borrowing, and modes in a small lambda calculus, for which we prove type safety and termination of specifications and proofs. We demonstrate Verus on a series of examples, including pointer-manipulating code (an xor-based doubly linked list), code with interior mutability, and concurrent code.},
journal = {Proc. ACM Program. Lang.},
month = {apr},
articleno = {85},
numpages = {30},
keywords = {systems verification, Rust, linear types}
}

@article{Prusti,
author = {Astrauskas, Vytautas and M\"{u}ller, Peter and Poli, Federico and Summers, Alexander J.},
title = {Leveraging Rust Types for Modular Specification and Verification},
year = {2019},
issue_date = {October 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {OOPSLA},
url = {https://doi.org/10.1145/3360573},
doi = {10.1145/3360573},
abstract = {Rust's type system ensures memory safety: well-typed Rust programs are guaranteed to not exhibit problems such as dangling pointers, data races, and unexpected side effects through aliased references. Ensuring correctness properties beyond memory safety, for instance, the guaranteed absence of assertion failures or more-general functional correctness, requires static program verification. For traditional system programming languages, formal verification is notoriously difficult and requires complex specifications and logics to reason about pointers, aliasing, and side effects on mutable state. This complexity is a major obstacle to the more-widespread verification of system software. In this paper, we present a novel verification technique that leverages Rust's type system to greatly simplify the specification and verification of system software written in Rust. We analyse information from the Rust compiler and synthesise a corresponding core proof for the program in a flavour of separation logic tailored to automation. To verify correctness properties beyond memory safety, users can annotate Rust programs with specifications at the abstraction level of Rust expressions; our technique weaves them into the core proof to verify modularly whether these specifications hold. Crucially, our proofs are constructed and checked automatically without exposing the underlying formal logic, allowing users to work exclusively at the level of abstraction of the programming language. As such, our work enables a new kind of verification tool, with the potential to impact a wide audience and allow the Rust community to benefit from state-of-the-art verification techniques. We have implemented our techniques for a subset of Rust; our evaluation on several thousand functions from widely-used Rust crates demonstrates its effectiveness.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {147},
numpages = {30},
keywords = {concurrency, heap-manipulating programs, Rust, type systems}
}

@inproceedings{Creusot,
author = {Denis, Xavier and Jourdan, Jacques-Henri and March\'{e}, Claude},
title = {Creusot: A Foundry For The Deductive Verification Of Rust Programs},
year = {2022},
isbn = {978-3-031-17243-4},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-031-17244-1_6},
doi = {10.1007/978-3-031-17244-1_6},
abstract = {Rust is a fairly recent programming language for system programming, bringing static guarantees of memory safety through a strict ownership policy. The strong guarantees brought by this feature opens promising progress for deductive verification, which aims at proving the conformity of Rust code with respect to a specification of its intended behavior. We present the foundations of Creusot, a tool for the formal specification and deductive verification of Rust code. A first originality comes from Creusot’s specification language, which features a notion of prophecy to reason about memory mutation, working in harmony with Rust’s ownership system. A second originality is how Creusot builds upon Rust trait system to provide several advanced abstraction features.},
booktitle = {Formal Methods and Software Engineering: 23rd International Conference on Formal Engineering Methods, ICFEM 2022, Madrid, Spain, October 24–27, 2022, Proceedings},
pages = {90–105},
numpages = {16},
keywords = {Aliasing and ownership, Rust programming language, Traits, Prophecies, Deductive program verification},
location = {Madrid, Spain}
}

@misc{Flux,
      title={Flux: Liquid Types for Rust}, 
      author={Nico Lehmann and Adam Geller and Niki Vazou and Ranjit Jhala},
      year={2022},
      eprint={2207.04034},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@misc{aarch64cpu,
  author={Adam Greig, Andre Richter},
  title={aarch64-cpu Rust crate},
  howpublished={\url{https://crates.io/crates/aarch64-cpu}},
  year={2023},
}

@misc{armgooglecloud,
  author={Arm},
  title={Arm Neoverse Adopted by Google Cloud},
  howpublished={\url{https://www.arm.com/company/news/2022/07/arm-neoverse-adopted-by-google-cloud}},
  year={2022},
}

@misc{armaws,
  author={Arm},
  title={Arm and AWS: Working together to "Re:Invent" the cloud},
  howpublished={\url{https://www.arm.com/company/news/2018/11/arm-and-aws-working-together-to-reinvent-the-cloud}},
  year={2018},
}

@inproceedings{kvmarm,
author = {Dall, Christoffer and Nieh, Jason},
title = {KVM/ARM: The Design and Implementation of the Linux ARM Hypervisor},
year = {2014},
isbn = {9781450323055},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2541940.2541946},
doi = {10.1145/2541940.2541946},
abstract = {As ARM CPUs become increasingly common in mobile devices and servers, there is a growing demand for providing the benefits of virtualization for ARM-based devices. We present our experiences building the Linux ARM hypervisor, KVM/ARM, the first full system ARM virtualization solution that can run unmodified guest operating systems on ARM multicore hardware. KVM/ARM introduces split-mode virtualization, allowing a hypervisor to split its execution across CPU modes and be integrated into the Linux kernel. This allows KVM/ARM to leverage existing Linux hardware support and functionality to simplify hypervisor development and maintainability while utilizing recent ARM hardware virtualization extensions to run virtual machines with comparable performance to native execution. KVM/ARM has been successfully merged into the mainline Linux kernel, ensuring that it will gain wide adoption as the virtualization platform of choice for ARM. We provide the first measurements on real hardware of a complete hypervisor using ARM hardware virtualization support. Our results demonstrate that KVM/ARM has modest virtualization performance and power costs, and can achieve lower performance and power costs compared to x86-based Linux virtualization on multicore hardware.},
booktitle = {Proceedings of the 19th International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {333–348},
numpages = {16},
keywords = {arm, multicore, virtualization, linux, operating systems, hypervisors},
location = {Salt Lake City, Utah, USA},
series = {ASPLOS '14}
}


@misc{kvmarmlwn,
  author = {Dall, Christoffer and Nieh, Jason},
  title={Supporting KVM on the ARM architecture},
  howpublished={\url{https://lwn.net/Articles/557132/}},
  year={2013},
}

@inproceedings{YCSB2,
author = {Cooper, Brian and Silberstein, Adam and Tam, Erwin and Ramakrishnan, Raghu and Sears, Russell},
year = {2010},
month = {09},
pages = {143-154},
title = {Benchmarking cloud serving systems with YCSB},
journal = {Proceedings of the 1st ACM Symposium on Cloud Computing, SoCC '10},
doi = {10.1145/1807128.1807152}
}

@misc{krustvmrepo,
  author={Chiang, Yu-Hsun and Chang, Wei-Lin and Du, Jan-Ting and Li, Shih-Wei},
  title={KrustVM: a Rust-based Secure KVM Hypervisor},
  howpublished={\url{https://github.com/ntu-ssl/linux-sekvm-rust}},
  year={2023},
}

@inproceedings{sel4,
author = {Klein, Gerwin and Elphinstone, Kevin and Heiser, Gernot and Andronick, June and Cock, David and Derrin, Philip and Elkaduwe, Dhammika and Engelhardt, Kai and Kolanski, Rafal and Norrish, Michael and Sewell, Thomas and Tuch, Harvey and Winwood, Simon},
title = {SeL4: Formal Verification of an OS Kernel},
year = {2009},
isbn = {9781605587523},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1629575.1629596},
doi = {10.1145/1629575.1629596},
abstract = {Complete formal verification is the only known way to guarantee that a system is free of programming errors.We present our experience in performing the formal, machine-checked verification of the seL4 microkernel from an abstract specification down to its C implementation. We assume correctness of compiler, assembly code, and hardware, and we used a unique design approach that fuses formal and operating systems techniques. To our knowledge, this is the first formal proof of functional correctness of a complete, general-purpose operating-system kernel. Functional correctness means here that the implementation always strictly follows our high-level abstract specification of kernel behaviour. This encompasses traditional design and implementation safety properties such as the kernel will never crash, and it will never perform an unsafe operation. It also proves much more: we can predict precisely how the kernel will behave in every possible situation.seL4, a third-generation microkernel of L4 provenance, comprises 8,700 lines of C code and 600 lines of assembler. Its performance is comparable to other high-performance L4 kernels.},
booktitle = {Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles},
pages = {207–220},
numpages = {14},
keywords = {sel4, microkernel, l4, isabelle/hol},
location = {Big Sky, Montana, USA},
series = {SOSP '09}
}

@inproceedings {certikos,
author = {Ronghui Gu and Zhong Shao and Hao Chen and Xiongnan (Newman) Wu and Jieung Kim and Vilhelm Sj{\"o}berg and David Costanzo},
title = {{CertiKOS}: An Extensible Architecture for Building Certified Concurrent {OS} Kernels},
booktitle = {12th USENIX Symposium on Operating Systems Design and Implementation (OSDI 16)},
year = {2016},
isbn = {978-1-931971-33-1},
address = {Savannah, GA},
pages = {653--669},
url = {https://www.usenix.org/conference/osdi16/technical-sessions/presentation/gu},
publisher = {USENIX Association},
month = nov,
}

@article{aeneas,
author = {Ho, Son and Protzenko, Jonathan},
title = {Aeneas: Rust Verification by Functional Translation},
year = {2022},
issue_date = {August 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {ICFP},
url = {https://doi.org/10.1145/3547647},
doi = {10.1145/3547647},
abstract = {We present Aeneas, a new verification toolchain for Rust programs based on a lightweight functional translation. We leverage Rust’s rich region-based type system to eliminate memory reasoning for a large class of Rust programs, as long as they do not rely on interior mutability or unsafe code. Doing so, we relieve the proof engineer of the burden of memory-based reasoning, allowing them to instead focus on functional properties of their code. The first contribution of Aeneas is a new approach to borrows and controlled aliasing. We propose a pure, functional semantics for LLBC, a Low-Level Borrow Calculus that captures a large subset of Rust programs. Our semantics is value-based, meaning there is no notion of memory, addresses or pointer arithmetic. Our semantics is also ownership-centric, meaning that we enforce soundness of borrows via a semantic criterion based on loans rather than through a syntactic type-based lifetime discipline. We claim that our semantics captures the essence of the borrow mechanism rather than its current implementation in the Rust compiler. The second contribution of Aeneas is a translation from LLBC to a pure lambda-calculus. This allows the user to reason about the original Rust program through the theorem prover of their choice, and fulfills our promise of enabling lightweight verification of Rust programs. To deal with the well-known technical difficulty of terminating a borrow, we rely on a novel approach, in which we approximate the borrow graph in the presence of function calls. This in turn allows us to perform the translation using a new technical device called backward functions. We implement our toolchain in a mixture of Rust and OCaml; our chief case study is a low-level, resizing hash table, for which we prove functional correctness, the first such result in Rust. Our evaluation shows significant gains of verification productivity for the programmer. This paper therefore establishes a new point in the design space of Rust verification toolchains, one that aims to verify Rust programs simply, and at scale. Rust goes to great lengths to enforce static control of aliasing; the proof engineer should not waste any time on memory reasoning when so much already comes “for free”!},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {116},
numpages = {31},
keywords = {functional translation, Rust, verification}
}
