% !TeX root = ../main.tex

\chapter{Introduction}

Hypervisors are essential to cloud computing. They manage the hardware
resources to provide the virtual machine (VMs) abstraction and host
these VMs in the cloud.
The widely used commodity
hypervisors, such as KVM~\cite{kivity07kvm} or Hyper-V~\cite{hyperv},
include a large and complex TCB to satisfy users' requirements in
performance and functionality. These hypervisors were written in unsafe
languages like C, making them vulnerable to safety bugs, such as
out-of-bound memory access and use-after-free. For example, KVM
integrates an entire Linux OS kernel inside its TCB. Attackers that
successfully exploit hypervisor vulnerabilities may gain the ability
to steal or modify secret VM data.

Previous work HypSec~\cite{hypsec} has retrofitted commodity hypervisors into a
small trusted core that enforces resource access control to ensure the
confidentiality and integrity of VM data against hypervisor and host operating
system exploits. However, the security of the whole system still depends on the
implementation of the small trusted TCB. Any vulnerability in the trusted TCB
can void the guarantees of VM data confidentiality and integrity.
While SeKVM~\cite{sekvm} extended the work of HypSec~\cite{hypsec} by formally
verifying the smaller TCB, the approach is not scalable since all code
modifications including the addition of new features, or code refactoring,
requires a new proof.

Rust is an emerging programming language that ensures strong memory safety
guarantees at compile time while offering performance efficiency.
Its distinctive ownership and lifetime system
effectively addresses potential safety issues that programmers may encounter.
Rust prevents various memory safety bugs, for example, null pointer
dereferences are eliminated by distinguishing between nullable and non
nullable types, nullable types are not allowed by default, array out-of-bound
accesses are prevented by runtime checks that are added by the compiler, and
Rust's ownership system prevents dangling pointers.
Further, similar to programming languages like C, Rust allows developers to
directly manage low-level systems resources such as memory. Due to these
attributes, various previous work has adopted Rust to implement systems
software with critical security and performance requirements, including
operating systems~\cite{NrOS, Redleaf, TockOS, theseus},
hypervisors~\cite{DuVisor, RustyHermit}, web browsers~\cite{servo},
and TEEs~\cite{rustsgx,rustee}.
There has been recent adoption of Rust in the mainline Linux kernel. However,
instead of replacing the existing Linux kernel code written in C with Rust,
the current efforts were limited to developing new Rust-based device drivers.

Our work implements a Linux KVM's TCB in Rust, so that the resulting hypervisor
benefits from the strong safety guarantees that Rust automatically provides.
%Our work leverages the Rust programming language and rewrite SeKVM \cite{sekvm},
%a secure Linux KVM hypervisor in Rust, so that the resulting hypervisor
%benefits from the strong safety guarantees that Rust automatically provides.
We build upon the work of SeKVM \cite{sekvm} and forward ported SeKVM
from Linux 4.18 to Linux 5.15, to take advantage of new kernel features
including Link-Time-Optimization (LTO) and energy-aware scheduling. SeKVM's
verified TCB \textit{\secore{}} is then rewritten in Rust, which is called
\textit{\rustcore{}}.
The resulting hypervisor, \rustsec{}, incorporates the small Rust TCB
\rustcore{} to
protect VM confidentiality and integrity against the large and untrusted
hypervisor codebase that encompasses KVM’s host Linux kernel.
We identified and overcame the challenges that arose when trying to
incorporate a Rust TCB inside Linux, rewrite SeKVM's TCB in Rust, and bring up
\rustsec{} on real hardware.
\rustcore{} is implemented in a way such that the amount of unsafe Rust is
minimized.
Unsafe code are enclosed within a safe abstraction and a safe API is exposed
in order to implement complex functionalities in safe Rust, including CPU,
memory, VM boot protection, VM exit, and hypercall handlers.
Further, raw pointer accesses, which are unsafe in Rust, are protected using
Rust’s type system. In \rustcore{}, raw pointers are used for accessing
physical memory. Physical memory is divided into multiple disjoint regions,
and the \rustcore{} implementation guarantees that all memory accesses done by
\rustcore{} are located in the predefined regions, ensuring that bugs caused by
pointers pointing to incorrect memory regions are prevented.
This is done in two parts, for raw pointer accesses to the region which stores
metadata used by \rustcore{}, called the \textit{\rustcore{} metadata region},
these accesses are bound via a set of reference getter functions (RGF).
Each RGF wraps a given Rcore’s raw pointer usage and returns a mutable
reference to the associated shared metadata object after the caller acquires
the corresponding lock. Because the raw pointer is turned into a mutable
reference, the memory accessed is guaranteed to be bound by the size of the
type being referenced, for arrays, the compiler automatically adds runtime
checks that checks for out-of-bound array indices.
For raw pointer accesses to the other regions, we built customized Rust types
for each memory region that enforces bound-checking, and \rustcore{} accesses
each memory region via the corresponding type.
%This is achieved with customized Rust types for each memory region that
%enforces bound-check to accesses, and mandating that \rustcore{} accesses a
%memory region via each corresponding type.

% describe the benefits
%We spent less than one person year rewriting SeKVM into \rustsec{}.
By rewriting a C-based hypervisor to a Rust-based implementation,
the responsibility of human auditing is shifted to the compiler.
This results in safer code and a more straightforward development process.
Performance evaluation of \rustsec{} on real Arm64 hardware shows that
\rustsec{} incurs modest performance overhead to application workloads
compared to mainline KVM and SeKVM. We demonstrate the practicality of
securing an existing commodity hypervisor by a C-to-Rust rewrite.

The rest of the thesis will be organized as follows. Background
will be reviewed in \autoref{sec:bg}. Our threat model and assumptions are
listed in \autoref{sec:threatmodel}. The process of implementing a Rust TCB
for KVM and the techniques used are described in \autoref{sec:rewrite}.
\autoref{sec:securercore} presents how Rust's safety features are utilized to
design and secure \rustcore{} memory accesses.
Evaluation of \rustsec{} and its comparison with mainline KVM and SeKVM is
covered in \autoref{sec:eval}. Related work and future work are discussed in
\autoref{sec:rwfw}. At last, we conclude the thesis in
\autoref{sec:conclusions}.
